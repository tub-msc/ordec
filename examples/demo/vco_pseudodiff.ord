# SPDX-FileCopyrightText: 2025 ORDeC contributors
# SPDX-License-Identifier: Apache-2.0

"""
Experimental voltage-controlled oscillator (VCO) example.

The VCO is a pseudodifferential ping oscillator generating 4 phases with 90
degree phase differences.
"""

from itertools import pairwise
import os
import subprocess

from ordec.core import *
from ordec.lib import ihp130
from ordec.lib.ihp130 import Nmos, Pmos
from ordec.lib.base import Res, Cap, Gnd, Vdc, NoConn, Vpwl
from ordec.schematic.routing import schematic_routing
from ordec.schematic.helpers import symbol_place_pins, add_conn_points
from ordec.sim import HighlevelSim
from ordec.report import *
from ordec.layout.makevias import makevias
from ordec.layout import write_gds
from ordec.layout import helpers
from ordec.ord2.context import ctx, OrdContext

cell VcoHalfStage:
    width = Parameter(R, default=300n)
    length = Parameter(R, default=130n)

    viewgen symbol:
        inout vdd_st(.align=Orientation.North)
        inout vss_st(.align=Orientation.South)
        inout vdd(.align=Orientation.North)
        inout vss(.align=Orientation.South)

        input rst_n(.align=Orientation.West)
        input inp(.align=Orientation.West)
        input fb(.align=Orientation.East)
        output out(.align=Orientation.East)
        output out_n(.align=Orientation.East)

    viewgen schematic:
        net b

        port vdd_st(.align=Orientation.East; .pos=(1,24))
        port vdd(.align=Orientation.East; .pos=(1,26))
        port vss_st(.align=Orientation.East; .pos=(1,6))
        port vss(.align=Orientation.East; .pos=(1,4))
        port inp(.align=Orientation.East; .pos=(1,21))
        port rst_n(.align=Orientation.East; .pos=(1,9))
        port fb(.align=Orientation.East; .pos=(15,15))
        port out(.align=Orientation.West; .pos=(24,18))
        port out_n(.align=Orientation.West; .pos=(30,18))

        Pmos m1(.s -- vdd_st; .b -- vdd; .g -- inp; .d -- out; .pos=(3, 19))
        Nmos m2(.s -- b; .b -- vss; .g -- inp; .d -- out; .pos=(3, 13))
        Nmos m3(.s -- vss_st; .b -- vss; .g -- rst_n; .d -- b; .pos=(3, 7))
        Pmos m4(.s -- vdd_st; .b -- vdd; .g -- rst_n; .d -- out; .pos=(10, 19))

        Pmos m5(.s -- vdd_st; .b -- vdd; .g -- fb; .d -- out; .pos=(17, 19))
        Nmos m6(.s -- vss_st; .b -- vss; .g -- fb; .d -- out; .pos=(17, 13))

        Pmos m7(.s -- vdd; .b -- vdd; .g -- out; .d -- out_n; .pos=(25, 19))
        Nmos m8(.s -- vss; .b -- vss; .g -- out; .d -- out_n; .pos=(25, 13))

        for mos in m1, m2, m3, m4, m5, m6, m7, m8:
            mos.$w = self.width
            mos.$l = self.length


    @generate
    def layout(self):
        layers = ihp130.SG13G2().layers
        l = Layout(ref_layers=layers, cell=self, symbol=self.symbol)
        s = Solver(l)

        pmos = self.schematic.m1.symbol.cell
        nmos = self.schematic.m2.symbol.cell

        l.m1 = LayoutInstance(ref=pmos.layout)
        l.m2 = LayoutInstance(ref=nmos.layout)
        
        l.m3 = LayoutInstance(ref=nmos.layout)
        l.m4 = LayoutInstance(ref=pmos.layout)

        l.m5 = LayoutInstance(ref=nmos.layout)
        l.m6 = LayoutInstance(ref=pmos.layout)
        
        l.m7 = LayoutInstance(ref=nmos.layout)
        l.m8 = LayoutInstance(ref=pmos.layout)

        grid = ((l.m2, l.m1), (l.m3, l.m4), (l.m5, l.m6), (l.m7, l.m8))

        s.constrain(l.m1.pos == (0, 0))
        s.constrain(l.m1.poly[0].rect.cx == l.m2.poly[0].rect.cx)

        s.constrain(l.m1.activ.rect.ly == l.m2.activ.rect.uy + 1500)

        for left, right in pairwise(grid):
            left_nmos, left_pmos = left
            right_nmos, right_pmos = right
            s.constrain(right_nmos.sd[0].rect.center == left_nmos.sd[1].rect.center)
            s.constrain(right_pmos.sd[0].rect.center == left_pmos.sd[1].rect.center)

        l.poly = PathNode()
        for idx, insts in enumerate(grid):
            l.poly[idx] = LayoutRect(layer=layers.GatPoly) 
            for inst in insts:
                s.constrain(l.poly[idx].rect.contains(inst.poly[0].rect))

        polycont_spec = (
            ('south', 'west', 'rst_n'),
            ('south', 'west', 'inp'),
            ('south', 'east', 'fb'),
            ('north', 'west', False),
        )
        l.polycont = PathNode()
        polycont_m1={}
        for idx, (vert_spec, horiz_spec, add_m1) in enumerate(polycont_spec):
            polyext = l % LayoutRect(layer=layers.GatPoly)
            s.constrain(polyext.rect.size == (300, 300))
            if horiz_spec == 'west':
                s.constrain(polyext.rect.ux == l.poly[idx].rect.ux)
            else:
                assert horiz_spec == 'east'
                s.constrain(polyext.rect.lx == l.poly[idx].rect.lx)
            if vert_spec == 'north':
                s.constrain(polyext.rect.uy == l.m1.activ.rect.ly - 200)
            else:
                assert vert_spec == 'south'
                s.constrain(polyext.rect.ly == l.m2.activ.rect.uy + 200)
            l.polycont[idx] = LayoutRect(layer=layers.Cont)
            s.constrain(l.polycont[idx].rect.size == (160, 160))
            s.constrain(l.polycont[idx].rect.center == polyext.rect.center)
            if add_m1:
                setattr(l, add_m1, LayoutRect(layer=layers.Metal1))
                m1 = getattr(l, add_m1)
                s.constrain(m1.rect.cx == l.polycont[idx].rect.cx + (-25 if horiz_spec=='west' else 25))
                s.constrain(m1.rect.width == 210)
                s.constrain(m1.rect.ly == l.m2.sd[0].rect.uy + 200)
                s.constrain(m1.rect.height == 600)

        l.rst_n % LayoutPin(pin=self.symbol.rst_n)
        l.inp % LayoutPin(pin=self.symbol.inp)
        l.fb % LayoutPin(pin=self.symbol.fb)

        l.outbar_h = LayoutRect(layer=layers.Metal1)
        l.outbar_h % LayoutPin(pin=self.symbol.out)
        s.constrain(l.outbar_h.rect.cy == l.polycont[3].rect.cy)
        s.constrain(l.outbar_h.rect.height == 210)
        s.constrain(l.outbar_h.rect.lx == l.m1.sd[0].rect.lx)
        s.constrain(l.outbar_h.rect.ux == l.polycont[3].rect.ux + 500)

        l.outbar_vmain = LayoutRect(layer=layers.Metal1)
        s.constrain(l.outbar_vmain.rect.contains(l.m3.sd[1].rect))
        s.constrain(l.outbar_vmain.rect.contains(l.m4.sd[1].rect))

        l.outbar_vrst = LayoutRect(layer=layers.Metal1)
        s.constrain(l.outbar_vrst.rect.contains(l.m1.sd[0].rect))
        s.constrain(l.outbar_vrst.rect.ly == l.outbar_h.rect.ly)

        l.outbar_outn = LayoutRect(layer=layers.Metal1)
        s.constrain(l.outbar_outn.rect.uy == l.m8.sd[1].rect.uy)
        s.constrain(l.outbar_outn.rect.ly == l.m7.sd[1].rect.ly)
        s.constrain(l.outbar_outn.rect.lx >= l.m7.sd[1].rect.ux)
        s.constrain(l.outbar_outn.rect.lx >= l.outbar_h.rect.ux + 200)
        s.constrain(l.outbar_outn.rect.width == 210)

        l.outbar_outn % LayoutPin(pin=self.symbol.out_n)

        for sd in (l.m8.sd[1], l.m7.sd[1]):
            r = l % LayoutRect(layer=layers.Metal1)
            s.constrain(r.rect.contains(sd.rect))
            s.constrain(r.rect.ux >= l.outbar_outn.rect.lx)

        l.vddbar = LayoutRect(layer=layers.Metal1)
        l.vddbar % LayoutPin(pin=self.symbol.vdd)
        s.constrain(l.vddbar.rect.southwest == l.m1.sd[0].rect.northwest + (-500,400))
        s.constrain(l.vddbar.rect.height == 400)
        s.constrain(l.vddbar.rect.ux == l.m7.sd[1].rect.ux + 500)

        for sd in (l.m4.sd[0], l.m8.sd[0]):
            r = l % LayoutRect(layer=layers.Metal1)
            s.constrain(r.rect.contains(sd.rect))
            s.constrain(r.rect.uy == l.vddbar.rect.ly)

        l.vssbar = LayoutRect(layer=layers.Metal1)
        l.vssbar % LayoutPin(pin=self.symbol.vss)
        s.constrain(l.vssbar.rect.width == l.vddbar.rect.width)
        s.constrain(l.vssbar.rect.height == 400)
        s.constrain(l.vssbar.rect.northwest == l.m2.sd[0].rect.southwest - (500,500))

        for sd in (l.m2.sd[0], l.m7.sd[0]):
            r = l % LayoutRect(layer=layers.Metal1)
            s.constrain(r.rect.contains(sd.rect))
            s.constrain(r.rect.ly == l.vssbar.rect.uy)

        r = l % LayoutRect(layer=layers.Metal1)
        s.constrain(r.rect.contains(l.m2.sd[1].rect))
        s.constrain(r.rect.height == 600)
        s.constrain(r.rect.uy == l.m2.sd[1].rect.uy)

        l.nwell = LayoutRect(layer=layers.NWell)
        for m in (l.m1, l.m4, l.m6, l.m8):
            s.constrain(l.nwell.rect.contains(m.nwell.rect))

        s.solve()
        return l

cell VcoRing:
    viewgen symbol:
        inout vdd_st(.align=Orientation.North)
        inout vss_st(.align=Orientation.South)
        inout vdd(.align=Orientation.North)
        inout vss(.align=Orientation.South)
        input rst_n(.align=Orientation.West)

        path out_p, out_n
        for i in range(2):
            output out_p[i](.align=Orientation.East)
            output out_n[i](.align=Orientation.East)


    viewgen schematic:
        port vdd_st(.pos=(1,21); .align=Orientation.East)
        port vdd   (.pos=(1,22); .align=Orientation.East)
        port vss_st(.pos=(1,1) ; .align=Orientation.East)
        port vss   (.pos=(1,0) ; .align=Orientation.East)
        port rst_n (.pos=(1,10); .align=Orientation.East)

        path out_p, out_n

        vdd_st.ref.route = False
        vss_st.ref.route = False
        vdd.ref.route = False
        vss.ref.route = False

        path int_p, int_n
        for i in range(2):
            net int_p[i]
            net int_n[i]

        path stage_p, stage_n

        for i in range(2):
            xoffset = 10 * i
            port out_p[i](.pos=(12 + xoffset, 17); .align=Orientation.West)
            port out_n[i](.pos=(12 + xoffset,  7); .align=Orientation.West)

            VcoHalfStage stage_p[i]:
                .out    -- int_p[i]
                .fb     -- int_n[i]
                .vdd    -- vdd
                .out_n  -- out_p[i]
                .vdd_st -- vdd_st
                .vss    -- vss
                .vss_st -- vss_st
                .rst_n  -- (rst_n if (i % 2) == 0 else vdd)
                .inp    -- (int_p[i-1] if i > 0 else int_n[1])
                .pos = (5 + xoffset, 13)

            VcoHalfStage stage_n[i]:
                .out    -- int_n[i]
                .fb     -- int_p[i]
                .out_n  -- out_n[i]
                .vdd    -- vdd
                .vdd_st -- vdd_st
                .vss    -- vss
                .vss_st -- vss_st
                .rst_n  -- (rst_n if (i % 2) == 1 else vdd)
                .inp    -- (int_n[i-1] if i > 0 else int_p[1])
                .pos = (5 + xoffset, 3)


    @generate
    def layout(self):
        layers = ihp130.SG13G2().layers
        l = Layout(ref_layers=layers, cell=self, symbol=self.symbol)
        s = Solver(l)

        l.stage_n = PathNode()
        l.stage_p = PathNode()
        l.out_n = PathNode()
        l.out_p = PathNode()

        l.nwell = LayoutRect(layer=layers.NWell)
       
        l.vdd_st_bar = LayoutRect(layer=layers.Metal1)
        l.vdd_st_bar % LayoutPin(pin=self.symbol.vdd_st)

        l.vss_st_bar_n = LayoutRect(layer=layers.Metal1)
        l.vss_st_bar_n % LayoutPin(pin=self.symbol.vss_st)

        l.vss_st_bar_p = LayoutRect(layer=layers.Metal1)
        l.vss_st_bar_p % LayoutPin(pin=self.symbol.vss_st)

        for i in range(2):
            l.stage_p[i] = LayoutInstance(ref=VcoHalfStage().layout, orientation=Orientation.MX)
            l.stage_n[i] = LayoutInstance(ref=VcoHalfStage().layout)
            if i == 0:
                l.stage_p[i].orientation *= Orientation.MY
                l.stage_n[i].orientation *= Orientation.MY
            s.constrain(l.stage_n[i].vddbar.rect.southwest == l.stage_p[i].vddbar.rect.southwest)

            if i > 0:
                s.constrain(l.stage_n[i].vddbar.rect.west == l.stage_n[i-1].vddbar.rect.east)

            s.constrain(l.nwell.rect.contains(l.stage_p[i].nwell.rect))
            s.constrain(l.nwell.rect.contains(l.stage_n[i].nwell.rect))

            outbar_n = l.stage_n[i].outbar_outn
            l.out_n[i] = LayoutRect(layer=outbar_n.layer.nid)
            s.constrain(l.out_n[i].rect == outbar_n.rect)
            l.out_n[i] % LayoutPin(pin=self.symbol.out_n[i])

            outbar_p = l.stage_p[i].outbar_outn
            l.out_p[i] = LayoutRect(layer=outbar_p.layer.nid)
            s.constrain(l.out_p[i].rect == outbar_p.rect)
            l.out_p[i] % LayoutPin(pin=self.symbol.out_p[i])

            s.constrain(l.vdd_st_bar.rect.contains(l.stage_p[i].vddbar.rect))
            s.constrain(l.vdd_st_bar.rect.contains(l.stage_n[i].vddbar.rect))

            s.constrain(l.vss_st_bar_n.rect.contains(l.stage_n[i].vssbar.rect))
            s.constrain(l.vss_st_bar_p.rect.contains(l.stage_p[i].vssbar.rect))

        vias = {layers.Via1: [], layers.Via2: []}

        s.constrain(l.stage_p[0].pos==(0,0))

        # Connect rst_n of stage_n[0] and stage_p[1] to VDD:
        l.rsttie = PathNode()
        for i, stage in enumerate([l.stage_n[0], l.stage_p[1]]):
            l.rsttie[i] = LayoutRectPath(2, layer=layers.Metal2, width=200, ext_bgn=150, ext_end=150, endtype=PathEndType.CUSTOM)
            s.constrain(l.rsttie[i][0] == stage.rst_n.rect.center)
            s.constrain(l.rsttie[i][1] == (l.rsttie[i][0].x, stage.vddbar.rect.cy))
            vias[layers.Via1] += [l.rsttie[i][0], l.rsttie[i][1]]

        # Connect rst_n of stage_n[1] and stage_p[0] to own rst_n:

        l.rst_n = LayoutRect(layer=layers.Metal2)
        s.constrain(l.rst_n.rect.width == 200)
        s.constrain(l.rst_n.rect.uy == l.stage_p[1].vssbar.rect.uy + 1000)
        s.constrain(l.rst_n.rect.cx == 0.5*l.stage_p[0].rst_n.rect.cx + 0.5*l.stage_n[1].rst_n.rect.cx)
        s.constrain(l.rst_n.rect.ly == l.stage_n[1].rst_n.rect.ly)
        l.rst_n % LayoutPin(pin=self.symbol.rst_n)

        r = l % LayoutRect(layer=layers.Metal2)
        s.constrain(r.rect.contains(l.stage_n[1].rst_n.rect))
        s.constrain(r.rect.lx == l.rst_n.rect.ux)

        vias[layers.Via1].append(l.stage_n[1].rst_n.rect.center)

        r = l % LayoutRect(layer=layers.Metal2)
        s.constrain(r.rect.contains(l.stage_p[0].rst_n.rect))
        s.constrain(r.rect.ux == l.rst_n.rect.lx)

        vias[layers.Via1].append(l.stage_p[0].rst_n.rect.center)

        # Connect out and fb pins of halfstage pairs on Metal2:

        l.outv_p = PathNode()
        l.outv_n = PathNode()

        for i in range(2):
            l.outv_p[i] = LayoutPath(2, layer=layers.Metal2, width=200, endtype=PathEndType.CUSTOM, ext_bgn=150, ext_end=150)
            s.constrain(l.outv_p[i][0] == l.stage_n[i].fb.rect.center)
            s.constrain(l.outv_p[i][1].x == l.outv_p[i][0].x)
            s.constrain(l.outv_p[i][1].y == l.stage_p[i].outbar_h.rect.cy)
            vias[layers.Via1] += [l.outv_p[i][0], l.outv_p[0][1]]

            l.outv_n[i] = LayoutPath(3, layer=layers.Metal2, width=200, endtype=PathEndType.CUSTOM, ext_bgn=150, ext_end=150)
            s.constrain(l.outv_n[i][0] == l.stage_p[i].fb.rect.center)
            if i == 0:
                s.constrain(l.outv_n[i][2] == l.stage_n[i].outbar_h.rect.west + (150, 0))
            else:
                s.constrain(l.outv_n[i][2] == l.stage_n[i].outbar_h.rect.east - (150,0))
            s.constrain(l.outv_n[i][1] == (l.outv_n[i][2].x, l.outv_n[i][0].y))
            vias[layers.Via1] += [l.outv_n[i][0], l.outv_n[i][2]]

        # Connect stage[0] inputs/outputs with stage[1] inputs/outputs:

        for inp, out in [
            (l.stage_n[1].inp, l.outv_n[0][2]),
            (l.stage_p[1].inp, l.outv_p[0][1]),
            (l.stage_n[0].inp, (l.outv_p[1][0].x, l.outv_n[0][2].y + 500)),
            (l.stage_p[0].inp, (l.outv_n[1][2].x, l.outv_p[0][1].y - 500))]:

            m3_horiz = l % LayoutPath(2, layer=layers.Metal3, width=200, endtype=PathEndType.CUSTOM, ext_bgn=150, ext_end=150)
            s.constrain(m3_horiz[0] == out)
            s.constrain(m3_horiz[1].y == m3_horiz[0].y)
            s.constrain(m3_horiz[1].x == inp.rect.cx)
            vias[layers.Via2] += [m3_horiz[0], m3_horiz[1]]

            m2_vert = l % LayoutPath(2, layer=layers.Metal2, width=200, endtype=PathEndType.CUSTOM, ext_bgn=150, ext_end=150)
            s.constrain(m2_vert[0] == inp.rect.center)
            s.constrain(m2_vert[1] == m3_horiz[1])
            vias[layers.Via1].append(m2_vert[0])

        # Add vias:
        for layer, vertices in vias.items():
            for vertex in vertices:
                via = l % LayoutRect(layer=layer)
                s.constrain(via.rect.size == (190, 190))
                s.constrain(via.rect.center == vertex)

        s.solve()
        return l

cell Vco:
    width = Parameter(R, default=300n)
    length = Parameter(R, default=130n)
    viewgen symbol:
        inout vdd(.align=Orientation.North)
        inout vss(.align=Orientation.South)

        input rst_n(.align=Orientation.West)
        input vbias(.align=Orientation.West)

        path out_p, out_n
        for i in range(2):
            output out_p[i](.align=Orientation.East)
            output out_n[i](.align=Orientation.East)

    viewgen schematic:
        port vdd  (.pos=(4,21); .align=Orientation.East)
        port vss  (.pos=(4,0) ; .align=Orientation.East)
        port rst_n(.pos=(13,9); .align=Orientation.East)
        port vbias(.pos=(4,6) ; .align=Orientation.East)

        net vss_st
        net vdd_st
        net cm_mid

        path out_p, out_n
        for i in range(2):
            port out_p[i](.pos=(22, 9 + 2 * i); .align=Orientation.West)
            port out_n[i](.pos=(22,10 + 2 * i); .align=Orientation.West)

        VcoRing ring:
            .vss     -- vss
            .vdd     -- vdd
            .vss_st  -- vss_st
            .vdd_st  -- vdd_st
            .rst_n   -- rst_n
            .pos = (15, 7)

        for i in range(2):
            ring.out_n[i] -- out_n[i]
            ring.out_p[i] -- out_p[i]

        Nmos m1:
            .d -- vss_st
            .s -- vss
            .b -- vss
            .g -- vbias
            .pos = (15, 1)

        Pmos m2:
            .d -- vdd_st
            .s -- vdd
            .b -- vdd
            .g -- cm_mid
            .pos = (15, 16)

        Pmos m3:
            .d -- cm_mid
            .g -- cm_mid
            .s -- vdd
            .b -- vdd
            .pos = (11, 16)
            .orientation = Orientation.FlippedSouth

        Nmos m4:
            .d -- cm_mid
            .s -- vss
            .b -- vss
            .g -- vbias
            .pos = (7, 1)

        for mos in m1, m2, m3, m4:
            mos.$l = self.length
            mos.$w = self.width

cell VcoTb:
    viewgen symbol:
        pass
    viewgen schematic:
        net vdd, vss, vbias, rst_n

        path out_p, out_n, nc

        Vco dut:
            .vss -- vss
            .vdd -- vdd
            .vbias -- vbias
            .rst_n -- rst_n
            .pos = (17, 6)

        for i in range(2):
            net out_n[i]
            net out_p[i]

            dut.out_n[i] -- out_n[i]
            dut.out_p[i] -- out_p[i]

            NoConn nc[2 * i + 0]:
                .a -- out_n[i]
                .pos = (22 + 5 * i, 6)
                .orientation = Orientation.East

            NoConn nc[2 * i + 1]:
                .a -- out_p[i]
                .pos = (26 + 5 * i, 17)
                .orientation = Orientation.West

        Gnd gnd:
            .p -- vss
            .pos = (0, 0)

        Vdc vdd_src:
            .m -- vss
            .p -- vdd
            .pos = (0, 10)
            .$dc = 1.2

        Vpwl vbias_src:
            .m -- vss
            .p -- vbias
            .pos = (5, 10)
            .$V = ((0, 1.2), (1n, 1.2), (30n, 0))

        Vpwl rst_n_src:
            .m -- vss
            .p -- rst_n
            .pos = (10, 10)
            .$V = ((0, 0), (1n, 0), (1.1n, 1.2))

    @generate
    def sim_tran(self):
        """Run sync transient simulation."""

        s = SimHierarchy.from_schematic(self.schematic)
        sim = HighlevelSim(s)
        sim.tran(R('10p'), R('30n'))
        return s

    @generate
    def report_tran(self):
        sim = self.sim_tran

        elements = [Markdown("## VCO transient main waveforms")]
        for i in range(2):
            elements.append(Plot2D(
                x=sim.time,
                series={
                    sim.out_n[i].full_path_str(): sim.out_n[i].trans_voltage,
                    sim.out_p[i].full_path_str(): sim.out_p[i].trans_voltage,
                },
                xlabel="Time (s)",
                ylabel="Voltage (V)",
                height=180,
                plot_group="vco_tran",
                ))
        elements.append(Plot2D(
            x=sim.time,
            series={
                'rst_n': sim.rst_n.trans_voltage,
                'vbias': sim.vbias.trans_voltage,
            },
            xlabel="Time (s)",
            ylabel="Voltage (V)",
            height=120,
            plot_group="vco_tran",
            ))
        elements.append(Plot2D(
            x=sim.time,
            series={'vdd_src': [-x for x in sim.vdd_src.trans_current]},
            xlabel="Time (s)",
            ylabel="Current (A)",
            height=120,
            plot_group="vco_tran",
            ))
        return Report(elements)

@generate_func
def report_analog_design():
    # Count transistors:
    transistor_table = []
    hier = SimHierarchy.from_schematic(Vco().schematic)
    for inst in hier.all(SimInstance):
        if type(inst.eref.cell).__name__ in ('Nmos', 'Pmos'):
            transistor_table.append(f'| {inst.full_path_str()} | {repr(inst.eref.cell)} |')
    transistor_count = len(transistor_table)

    # Count rectangles:
    layout = VcoRing().layout.mutable_copy()
    helpers.flatten(layout)

    rect_count = 0
    for rect in layout.all(LayoutRect):
        rect_count += 1
    for path in layout.all(LayoutPath):
        vertex_count = len(path.vertices())
        if vertex_count < 2:
            continue
        rect_count += (vertex_count - 1)

    netlist = HighlevelSim(SimHierarchy.from_schematic(Vco().schematic)).netlister.out()

    nl = chr(10) # TODO: Fix ORD2 string literal bug

    return Report([
        Markdown("# Analog design report: Pseudo-differential voltage-controlled ring oscillator"),
        Svg.from_view(Vco().symbol),
        Markdown(
            f"## Transistor count (schematic){nl}"
            f"There are **{transistor_count}** transistors in the example design.{nl}"
            f"{nl}"
            f" | Instance Name | Reference |{nl}"
            f"| -- | -- |{nl}"
            + f'{nl}'.join(transistor_table) +
            f"{nl}"
            f"## Rectangle count (layout){nl}"
            f"The layout comprises **{rect_count}** rectangles.{nl}"
            f"{nl}"
            f"(This is only the VcoRing part.){nl}"
            f"## Vco netlist"
        ),
        PreformattedText(netlist)
    ])
