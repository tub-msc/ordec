# SPDX-FileCopyrightText: 2025 ORDeC contributors
# SPDX-License-Identifier: Apache-2.0

"""
Experimental voltage-controlled oscillator (VCO) example.

The VCO is a pseudodifferential ping oscillator generating 4 phases with 90
degree phase differences.
"""

from itertools import pairwise
import os
import subprocess

from ordec.core import *
from ordec.lib import ihp130
from ordec.lib.ihp130 import Nmos, Pmos
from ordec.lib.base import Res, Cap, Gnd, Vdc, NoConn, Vpwl
from ordec.sim import HighlevelSim
from ordec.report import *
from ordec.layout.makevias import makevias
from ordec.layout import write_gds
from ordec.layout import helpers

cell VcoHalfStage:
    width = Parameter(R, default=300n)
    length = Parameter(R, default=130n)

    viewgen symbol:
        inout vdd_st: .align=Orientation.North
        inout vss_st: .align=Orientation.South
        inout vdd: .align=Orientation.North
        inout vss: .align=Orientation.South

        input rst_n: .align=Orientation.West
        input inp: .align=Orientation.West
        input fb: .align=Orientation.East
        output out: .align=Orientation.East
        output out_n: .align=Orientation.East

    viewgen schematic:
        net b

        port vdd_st: .align=Orientation.East; .pos=(1,24)
        port vdd: .align=Orientation.East; .pos=(1,26)
        port vss_st: .align=Orientation.East; .pos=(1,6)
        port vss: .align=Orientation.East; .pos=(1,4)
        port inp: .align=Orientation.East; .pos=(1,21)
        port rst_n: .align=Orientation.East; .pos=(1,9)
        port fb: .align=Orientation.East; .pos=(15,15)
        port out: .align=Orientation.West; .pos=(24,18)
        port out_n: .align=Orientation.West; .pos=(30,18)

        Pmos m1: .s -- vdd_st; .b -- vdd; .g -- inp; .d -- out; .pos=(3, 19)
        Nmos m2: .s -- b; .b -- vss; .g -- inp; .d -- out; .pos=(3, 13)
        Nmos m3: .s -- vss_st; .b -- vss; .g -- rst_n; .d -- b; .pos=(3, 7)
        Pmos m4: .s -- vdd_st; .b -- vdd; .g -- rst_n; .d -- out; .pos=(10, 19)

        Pmos m5: .s -- vdd_st; .b -- vdd; .g -- fb; .d -- out; .pos=(17, 19)
        Nmos m6: .s -- vss_st; .b -- vss; .g -- fb; .d -- out; .pos=(17, 13)

        Pmos m7: .s -- vdd; .b -- vdd; .g -- out; .d -- out_n; .pos=(25, 19)
        Nmos m8: .s -- vss; .b -- vss; .g -- out; .d -- out_n; .pos=(25, 13)

        for mos in m1, m2, m3, m4, m5, m6, m7, m8:
            mos.$w = self.width
            mos.$l = self.length


    viewgen layout(layers=ihp130.SG13G2().layers):
        pmos = self.schematic.m1.symbol.cell
        nmos = self.schematic.m2.symbol.cell

        .m1 = LayoutInstance(ref=pmos.layout)
        .m2 = LayoutInstance(ref=nmos.layout)

        .m3 = LayoutInstance(ref=nmos.layout)
        .m4 = LayoutInstance(ref=pmos.layout)

        .m5 = LayoutInstance(ref=nmos.layout)
        .m6 = LayoutInstance(ref=pmos.layout)

        .m7 = LayoutInstance(ref=nmos.layout)
        .m8 = LayoutInstance(ref=pmos.layout)

        grid = ((.m2, .m1), (.m3, .m4), (.m5, .m6), (.m7, .m8))

        ! .m1.pos == (0, 0)
        ! .m1.poly[0].rect.cx == .m2.poly[0].rect.cx

        ! .m1.activ.rect.ly == .m2.activ.rect.uy + 1500

        for left, right in pairwise(grid):
            left_nmos, left_pmos = left
            right_nmos, right_pmos = right
            ! right_nmos.sd[0].rect.center == left_nmos.sd[1].rect.center
            ! right_pmos.sd[0].rect.center == left_pmos.sd[1].rect.center

        path poly
        for idx, insts in enumerate(grid):
            .poly[idx] = LayoutRect(layer=layers.GatPoly)
            for inst in insts:
                ! .poly[idx].rect.contains(inst.poly[0].rect)

        polycont_spec = (
            ('south', 'west', 'rst_n'),
            ('south', 'west', 'inp'),
            ('south', 'east', 'fb'),
            ('north', 'west', False),
        )
        path polycont
        polycont_m1={}
        for idx, (vert_spec, horiz_spec, add_m1) in enumerate(polycont_spec):
            polyext = . % LayoutRect(layer=layers.GatPoly)
            ! polyext.rect.size == (300, 300)
            if horiz_spec == 'west':
                ! polyext.rect.ux == .poly[idx].rect.ux
            else:
                assert horiz_spec == 'east'
                ! polyext.rect.lx == .poly[idx].rect.lx
            if vert_spec == 'north':
                ! polyext.rect.uy == .m1.activ.rect.ly - 200
            else:
                assert vert_spec == 'south'
                ! polyext.rect.ly == .m2.activ.rect.uy + 200
            .polycont[idx] = LayoutRect(layer=layers.Cont)
            ! .polycont[idx].rect.size == (160, 160)
            ! .polycont[idx].rect.center == polyext.rect.center
            if add_m1:
                setattr(., add_m1, LayoutRect(layer=layers.Metal1))
                m1 = getattr(., add_m1)
                ! m1.rect.cx == .polycont[idx].rect.cx + (-25 if horiz_spec=='west' else 25)
                ! m1.rect.width == 210
                ! m1.rect.ly == .m2.sd[0].rect.uy + 200
                ! m1.rect.height == 600

        .rst_n % LayoutPin(pin=self.symbol.rst_n)
        .inp % LayoutPin(pin=self.symbol.inp)
        .fb % LayoutPin(pin=self.symbol.fb)

        .outbar_h = LayoutRect(layer=layers.Metal1)
        .outbar_h % LayoutPin(pin=self.symbol.out)
        ! .outbar_h.rect.cy == .polycont[3].rect.cy
        ! .outbar_h.rect.height == 210
        ! .outbar_h.rect.lx == .m1.sd[0].rect.lx
        ! .outbar_h.rect.ux == .polycont[3].rect.ux + 500

        .outbar_vmain = LayoutRect(layer=layers.Metal1)
        ! .outbar_vmain.rect.contains(.m3.sd[1].rect)
        ! .outbar_vmain.rect.contains(.m4.sd[1].rect)

        .outbar_vrst = LayoutRect(layer=layers.Metal1)
        ! .outbar_vrst.rect.contains(.m1.sd[0].rect)
        ! .outbar_vrst.rect.ly == .outbar_h.rect.ly

        .outbar_outn = LayoutRect(layer=layers.Metal1)
        ! .outbar_outn.rect.uy == .m8.sd[1].rect.uy
        ! .outbar_outn.rect.ly == .m7.sd[1].rect.ly
        ! .outbar_outn.rect.lx >= .m7.sd[1].rect.ux
        ! .outbar_outn.rect.lx >= .outbar_h.rect.ux + 200
        ! .outbar_outn.rect.width == 210

        .outbar_outn % LayoutPin(pin=self.symbol.out_n)

        for sd in (.m8.sd[1], .m7.sd[1]):
            r = . % LayoutRect(layer=layers.Metal1)
            ! r.rect.contains(sd.rect)
            ! r.rect.ux >= .outbar_outn.rect.lx

        .vddbar = LayoutRect(layer=layers.Metal1)
        .vddbar % LayoutPin(pin=self.symbol.vdd)
        ! .vddbar.rect.southwest == .m1.sd[0].rect.northwest + (-500,400)
        ! .vddbar.rect.height == 400
        ! .vddbar.rect.ux == .m7.sd[1].rect.ux + 500

        for sd in (.m4.sd[0], .m8.sd[0]):
            r = . % LayoutRect(layer=layers.Metal1)
            ! r.rect.contains(sd.rect)
            ! r.rect.uy == .vddbar.rect.ly

        .vssbar = LayoutRect(layer=layers.Metal1)
        .vssbar % LayoutPin(pin=self.symbol.vss)
        ! .vssbar.rect.width == .vddbar.rect.width
        ! .vssbar.rect.height == 400
        ! .vssbar.rect.northwest == .m2.sd[0].rect.southwest - (500,500)

        for sd in (.m2.sd[0], .m7.sd[0]):
            r = . % LayoutRect(layer=layers.Metal1)
            ! r.rect.contains(sd.rect)
            ! r.rect.ly == .vssbar.rect.uy

        r = . % LayoutRect(layer=layers.Metal1)
        ! r.rect.contains(.m2.sd[1].rect)
        ! r.rect.height == 600
        ! r.rect.uy == .m2.sd[1].rect.uy

        .nwell = LayoutRect(layer=layers.NWell)
        for m in (.m1, .m4, .m6, .m8):
            ! .nwell.rect.contains(m.nwell.rect)

cell VcoRing:
    viewgen symbol:
        inout vdd_st: .align=Orientation.North
        inout vss_st: .align=Orientation.South
        inout vdd: .align=Orientation.North
        inout vss: .align=Orientation.South
        input rst_n: .align=Orientation.West

        path out_p, out_n
        for i in range(2):
            output out_p[i]: .align=Orientation.East
            output out_n[i]: .align=Orientation.East


    viewgen schematic:
        port vdd_st: .pos=(1,21); .align=Orientation.East
        port vdd: .pos=(1,22); .align=Orientation.East
        port vss_st: .pos=(1,1); .align=Orientation.East
        port vss: .pos=(1,0); .align=Orientation.East
        port rst_n: .pos=(1,10); .align=Orientation.East

        path out_p, out_n

        vdd_st.ref.route = False
        vss_st.ref.route = False
        vdd.ref.route = False
        vss.ref.route = False

        path int_p, int_n
        for i in range(2):
            net int_p[i]
            net int_n[i]

        path stage_p, stage_n

        for i in range(2):
            xoffset = 10 * i
            port out_p[i]: .pos=(12 + xoffset, 17); .align=Orientation.West
            port out_n[i]: .pos=(12 + xoffset,  7); .align=Orientation.West

            VcoHalfStage stage_p[i]:
                .out    -- int_p[i]
                .fb     -- int_n[i]
                .vdd    -- vdd
                .out_n  -- out_p[i]
                .vdd_st -- vdd_st
                .vss    -- vss
                .vss_st -- vss_st
                .rst_n  -- (rst_n if (i % 2) == 0 else vdd)
                .inp    -- (int_p[i-1] if i > 0 else int_n[1])
                .pos = (5 + xoffset, 13)

            VcoHalfStage stage_n[i]:
                .out    -- int_n[i]
                .fb     -- int_p[i]
                .out_n  -- out_n[i]
                .vdd    -- vdd
                .vdd_st -- vdd_st
                .vss    -- vss
                .vss_st -- vss_st
                .rst_n  -- (rst_n if (i % 2) == 1 else vdd)
                .inp    -- (int_n[i-1] if i > 0 else int_p[1])
                .pos = (5 + xoffset, 3)


    viewgen layout(layers=ihp130.SG13G2().layers):
        path stage_n, stage_p, out_n, out_p

        .nwell = LayoutRect(layer=layers.NWell)

        .vdd_st_bar = LayoutRect(layer=layers.Metal1)
        .vdd_st_bar % LayoutPin(pin=self.symbol.vdd_st)

        .vss_st_bar_n = LayoutRect(layer=layers.Metal1)
        .vss_st_bar_n % LayoutPin(pin=self.symbol.vss_st)

        .vss_st_bar_p = LayoutRect(layer=layers.Metal1)
        .vss_st_bar_p % LayoutPin(pin=self.symbol.vss_st)

        for i in range(2):
            .stage_p[i] = LayoutInstance(ref=VcoHalfStage().layout, orientation=Orientation.MX)
            .stage_n[i] = LayoutInstance(ref=VcoHalfStage().layout)
            if i == 0:
                .stage_p[i].orientation *= Orientation.MY
                .stage_n[i].orientation *= Orientation.MY
            ! .stage_n[i].vddbar.rect.southwest == .stage_p[i].vddbar.rect.southwest

            if i > 0:
                ! .stage_n[i].vddbar.rect.west == .stage_n[i-1].vddbar.rect.east

            ! .nwell.rect.contains(.stage_p[i].nwell.rect)
            ! .nwell.rect.contains(.stage_n[i].nwell.rect)

            outbar_n = .stage_n[i].outbar_outn
            .out_n[i] = LayoutRect(layer=outbar_n.layer.nid)
            ! .out_n[i].rect == outbar_n.rect
            .out_n[i] % LayoutPin(pin=self.symbol.out_n[i])

            outbar_p = .stage_p[i].outbar_outn
            .out_p[i] = LayoutRect(layer=outbar_p.layer.nid)
            ! .out_p[i].rect == outbar_p.rect
            .out_p[i] % LayoutPin(pin=self.symbol.out_p[i])

            ! .vdd_st_bar.rect.contains(.stage_p[i].vddbar.rect)
            ! .vdd_st_bar.rect.contains(.stage_n[i].vddbar.rect)

            ! .vss_st_bar_n.rect.contains(.stage_n[i].vssbar.rect)
            ! .vss_st_bar_p.rect.contains(.stage_p[i].vssbar.rect)

        vias = {layers.Via1: [], layers.Via2: []}

        ! .stage_p[0].pos == (0,0)

        # Connect rst_n of stage_n[0] and stage_p[1] to VDD:
        path rsttie
        for i, stage in enumerate([.stage_n[0], .stage_p[1]]):
            .rsttie[i] = LayoutRectPath(2, layer=layers.Metal2, width=200, ext_bgn=150, ext_end=150)
            ! .rsttie[i][0] == stage.rst_n.rect.center
            ! .rsttie[i][1] == (.rsttie[i][0].x, stage.vddbar.rect.cy)
            vias[layers.Via1] += [.rsttie[i][0], .rsttie[i][1]]

        # Connect rst_n of stage_n[1] and stage_p[0] to own rst_n:

        .rst_n = LayoutRect(layer=layers.Metal2)
        ! .rst_n.rect.width == 200
        ! .rst_n.rect.uy == .stage_p[1].vssbar.rect.uy + 1000
        ! .rst_n.rect.cx == 0.5*.stage_p[0].rst_n.rect.cx + 0.5*.stage_n[1].rst_n.rect.cx
        ! .rst_n.rect.ly == .stage_n[1].rst_n.rect.ly
        .rst_n % LayoutPin(pin=self.symbol.rst_n)

        r = . % LayoutRect(layer=layers.Metal2)
        ! r.rect.contains(.stage_n[1].rst_n.rect)
        ! r.rect.lx == .rst_n.rect.ux

        vias[layers.Via1].append(.stage_n[1].rst_n.rect.center)

        r = . % LayoutRect(layer=layers.Metal2)
        ! r.rect.contains(.stage_p[0].rst_n.rect)
        ! r.rect.ux == .rst_n.rect.lx

        vias[layers.Via1].append(.stage_p[0].rst_n.rect.center)

        # Connect out and fb pins of halfstage pairs on Metal2:

        path outv_p, outv_n

        for i in range(2):
            .outv_p[i] = LayoutPath(2, layer=layers.Metal2, width=200, ext_bgn=150, ext_end=150)
            ! .outv_p[i][0] == .stage_n[i].fb.rect.center
            ! .outv_p[i][1].x == .outv_p[i][0].x
            ! .outv_p[i][1].y == .stage_p[i].outbar_h.rect.cy
            vias[layers.Via1] += [.outv_p[i][0], .outv_p[0][1]]

            .outv_n[i] = LayoutPath(3, layer=layers.Metal2, width=200, ext_bgn=150, ext_end=150)
            ! .outv_n[i][0] == .stage_p[i].fb.rect.center
            if i == 0:
                ! .outv_n[i][2] == .stage_n[i].outbar_h.rect.west + (150, 0)
            else:
                ! .outv_n[i][2] == .stage_n[i].outbar_h.rect.east - (150,0)
            ! .outv_n[i][1] == (.outv_n[i][2].x, .outv_n[i][0].y)
            vias[layers.Via1] += [.outv_n[i][0], .outv_n[i][2]]

        # Connect stage[0] inputs/outputs with stage[1] inputs/outputs:

        for inp, out in [
            (.stage_n[1].inp, .outv_n[0][2]),
            (.stage_p[1].inp, .outv_p[0][1]),
            (.stage_n[0].inp, (.outv_p[1][0].x, .outv_n[0][2].y + 500)),
            (.stage_p[0].inp, (.outv_n[1][2].x, .outv_p[0][1].y - 500))]:

            m3_horiz = . % LayoutPath(2, layer=layers.Metal3, width=200, ext_bgn=150, ext_end=150)
            ! m3_horiz[0] == out
            ! m3_horiz[1].y == m3_horiz[0].y
            ! m3_horiz[1].x == inp.rect.cx
            vias[layers.Via2] += [m3_horiz[0], m3_horiz[1]]

            m2_vert = . % LayoutPath(2, layer=layers.Metal2, width=200, ext_bgn=150, ext_end=150)
            ! m2_vert[0] == inp.rect.center
            ! m2_vert[1] == m3_horiz[1]
            vias[layers.Via1].append(m2_vert[0])

        # Add vias:
        for layer, vertices in vias.items():
            for vertex in vertices:
                via = . % LayoutRect(layer=layer)
                ! via.rect.size == (190, 190)
                ! via.rect.center == vertex

cell Vco:
    width = Parameter(R, default=300n)
    length = Parameter(R, default=130n)
    viewgen symbol:
        inout vdd: .align=Orientation.North
        inout vss: .align=Orientation.South

        input rst_n: .align=Orientation.West
        input vbias: .align=Orientation.West

        path out_p, out_n
        for i in range(2):
            output out_p[i]: .align=Orientation.East
            output out_n[i]: .align=Orientation.East

    viewgen schematic:
        port vdd: .pos=(4,21); .align=Orientation.East
        port vss: .pos=(4,0); .align=Orientation.East
        port rst_n: .pos=(13,9); .align=Orientation.East
        port vbias: .pos=(4,6); .align=Orientation.East

        net vss_st
        net vdd_st
        net cm_mid

        path out_p, out_n
        for i in range(2):
            port out_p[i]: .pos=(22, 9 + 2 * i); .align=Orientation.West
            port out_n[i]: .pos=(22,10 + 2 * i); .align=Orientation.West

        VcoRing ring:
            .vss     -- vss
            .vdd     -- vdd
            .vss_st  -- vss_st
            .vdd_st  -- vdd_st
            .rst_n   -- rst_n
            .pos = (15, 7)

        for i in range(2):
            ring.out_n[i] -- out_n[i]
            ring.out_p[i] -- out_p[i]

        Nmos m1:
            .d -- vss_st
            .s -- vss
            .b -- vss
            .g -- vbias
            .pos = (15, 1)

        Pmos m2:
            .d -- vdd_st
            .s -- vdd
            .b -- vdd
            .g -- cm_mid
            .pos = (15, 16)

        Pmos m3:
            .d -- cm_mid
            .g -- cm_mid
            .s -- vdd
            .b -- vdd
            .pos = (11, 16)
            .orientation = Orientation.FlippedSouth

        Nmos m4:
            .d -- cm_mid
            .s -- vss
            .b -- vss
            .g -- vbias
            .pos = (7, 1)

        for mos in m1, m2, m3, m4:
            mos.$l = self.length
            mos.$w = self.width

cell VcoTb:
    viewgen symbol:
        pass
    viewgen schematic:
        net vdd, vss, vbias, rst_n

        path out_p, out_n, nc

        Vco dut:
            .vss -- vss
            .vdd -- vdd
            .vbias -- vbias
            .rst_n -- rst_n
            .pos = (17, 6)

        for i in range(2):
            net out_n[i]
            net out_p[i]

            dut.out_n[i] -- out_n[i]
            dut.out_p[i] -- out_p[i]

            NoConn nc[2 * i + 0]:
                .a -- out_n[i]
                .pos = (22 + 5 * i, 6)
                .orientation = Orientation.East

            NoConn nc[2 * i + 1]:
                .a -- out_p[i]
                .pos = (26 + 5 * i, 17)
                .orientation = Orientation.West

        Gnd gnd:
            .p -- vss
            .pos = (0, 0)

        Vdc vdd_src:
            .m -- vss
            .p -- vdd
            .pos = (0, 10)
            .$dc = 1.2

        Vpwl vbias_src:
            .m -- vss
            .p -- vbias
            .pos = (5, 10)
            .$V = ((0, 1.2), (1n, 1.2), (30n, 0))

        Vpwl rst_n_src:
            .m -- vss
            .p -- rst_n
            .pos = (10, 10)
            .$V = ((0, 0), (1n, 0), (1.1n, 1.2))

    @generate
    def sim_tran(self):
        """Run sync transient simulation."""

        s = SimHierarchy.from_schematic(self.schematic)
        sim = HighlevelSim(s)
        sim.tran(R('10p'), R('30n'))
        return s

    @generate
    def report_tran(self):
        sim = self.sim_tran

        elements = [Markdown("## VCO transient main waveforms")]
        for i in range(2):
            elements.append(Plot2D(
                x=sim.time,
                series={
                    sim.out_n[i].full_path_str(): sim.out_n[i].trans_voltage,
                    sim.out_p[i].full_path_str(): sim.out_p[i].trans_voltage,
                },
                xlabel="Time (s)",
                ylabel="Voltage (V)",
                height=180,
                plot_group="vco_tran",
                ))
        elements.append(Plot2D(
            x=sim.time,
            series={
                'rst_n': sim.rst_n.trans_voltage,
                'vbias': sim.vbias.trans_voltage,
            },
            xlabel="Time (s)",
            ylabel="Voltage (V)",
            height=120,
            plot_group="vco_tran",
            ))
        elements.append(Plot2D(
            x=sim.time,
            series={'vdd_src': [-x for x in sim.vdd_src.trans_current]},
            xlabel="Time (s)",
            ylabel="Current (A)",
            height=120,
            plot_group="vco_tran",
            ))
        return Report(elements)

@generate_func
def report_analog_design():
    # Count transistors:
    transistor_table = []
    hier = SimHierarchy.from_schematic(Vco().schematic)
    for inst in hier.all(SimInstance):
        if type(inst.eref.cell).__name__ in ('Nmos', 'Pmos'):
            transistor_table.append(f'| {inst.full_path_str()} | {repr(inst.eref.cell)} |')
    transistor_count = len(transistor_table)

    # Count rectangles:
    layout = VcoRing().layout.mutable_copy()
    helpers.flatten(layout)

    rect_count = 0
    for rect in layout.all(LayoutRect):
        rect_count += 1
    for path in layout.all(LayoutPath):
        vertex_count = len(path.vertices())
        if vertex_count < 2:
            continue
        rect_count += (vertex_count - 1)

    netlist = HighlevelSim(SimHierarchy.from_schematic(Vco().schematic)).netlister.out()

    return Report([
        Markdown("# Analog design report: Pseudo-differential voltage-controlled ring oscillator"),
        Svg.from_view(Vco().symbol),
        Markdown(
            f"## Transistor count (schematic)\n"
            f"There are **{transistor_count}** transistors in the example design.\n"
            f"\n"
            f" | Instance Name | Reference |\n"
            f"| -- | -- |\n"
            + f'\n'.join(transistor_table) +
            f"\n"
            f"## Rectangle count (layout)\n"
            f"The layout comprises **{rect_count}** rectangles.\n"
            f"\n"
            f"(This is only the VcoRing part.)\n"
            f"## Vco netlist"
        ),
        PreformattedText(netlist)
    ])
